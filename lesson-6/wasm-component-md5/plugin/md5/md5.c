// Generated by `wit-bindgen` 0.6.0. DO NOT EDIT!
#include "md5.h"

__attribute__((weak, export_name("cabi_post_md5#init")))
void __wasm_export_md5_init_post_return(int32_t arg0) {
  switch ((int32_t) (int32_t) (*((uint8_t*) (arg0 + 0)))) {
    case 0: {
      int32_t ptr = *((int32_t*) (arg0 + 32));
      int32_t len = *((int32_t*) (arg0 + 36));
      for (int32_t i = 0; i < len; i++) {
        int32_t base = ptr + i * 1;
        (void) base;
      }
      if (len > 0) {
        free((void*) (ptr));
      }
      break;
    }
    case 1: {
      break;
    }
  }
}
__attribute__((weak, export_name("cabi_post_md5#update")))
void __wasm_export_md5_update_post_return(int32_t arg0) {
  switch ((int32_t) (int32_t) (*((uint8_t*) (arg0 + 0)))) {
    case 0: {
      int32_t ptr = *((int32_t*) (arg0 + 32));
      int32_t len = *((int32_t*) (arg0 + 36));
      for (int32_t i = 0; i < len; i++) {
        int32_t base = ptr + i * 1;
        (void) base;
      }
      if (len > 0) {
        free((void*) (ptr));
      }
      break;
    }
    case 1: {
      break;
    }
  }
}
__attribute__((weak, export_name("cabi_post_md5#hash")))
void __wasm_export_md5_hash_post_return(int32_t arg0) {
  switch ((int32_t) (int32_t) (*((uint8_t*) (arg0 + 0)))) {
    case 0: {
      int32_t ptr = *((int32_t*) (arg0 + 4));
      int32_t len = *((int32_t*) (arg0 + 8));
      for (int32_t i = 0; i < len; i++) {
        int32_t base = ptr + i * 1;
        (void) base;
      }
      if (len > 0) {
        free((void*) (ptr));
      }
      break;
    }
    case 1: {
      break;
    }
  }
}

__attribute__((weak, export_name("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

// Helper Functions

void md5_list_u8_free(md5_list_u8_t *ptr) {
  if (ptr->len > 0) {
    free(ptr->ptr);
  }
}

void md5hash_context_free(md5hash_context_t *ptr) {
  md5_list_u8_free(&ptr->buffer);
}

void md5_result_context_errno_free(md5_result_context_errno_t *ptr) {
  if (!ptr->is_err) {
    md5hash_context_free(&ptr->val.ok);
  }
}

void md5_result_list_u8_errno_free(md5_result_list_u8_errno_t *ptr) {
  if (!ptr->is_err) {
    md5_list_u8_free(&ptr->val.ok);
  }
}

// Component Adapters

__attribute__((aligned(8)))
static uint8_t RET_AREA[40];

__attribute__((export_name("md5#init")))
int32_t __wasm_export_md5_init(void) {
  md5_result_context_errno_t ret;
  md5_init(&ret);
  int32_t ptr = (int32_t) &RET_AREA;
  if ((ret).is_err) {
    const md5hash_errno_t *payload0 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) *payload0;
  } else {
    const md5hash_context_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int64_t*)(ptr + 8)) = (int64_t) ((*payload).bytes);
    *((int32_t*)(ptr + 16)) = (int32_t) ((*payload).a);
    *((int32_t*)(ptr + 20)) = (int32_t) ((*payload).b);
    *((int32_t*)(ptr + 24)) = (int32_t) ((*payload).c);
    *((int32_t*)(ptr + 28)) = (int32_t) ((*payload).d);
    *((int32_t*)(ptr + 36)) = (int32_t) ((*payload).buffer).len;
    *((int32_t*)(ptr + 32)) = (int32_t) ((*payload).buffer).ptr;
  }
  return ptr;
}

__attribute__((export_name("md5#update")))
int32_t __wasm_export_md5_update(int64_t arg, int32_t arg0, int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7) {
  md5hash_context_t arg8 = (md5hash_context_t) {
    (uint64_t) (arg),
    (uint32_t) (arg0),
    (uint32_t) (arg1),
    (uint32_t) (arg2),
    (uint32_t) (arg3),
    (md5_list_u8_t) { (uint8_t*)(arg4), (size_t)(arg5) },
  };
  md5_list_u8_t arg9 = (md5_list_u8_t) { (uint8_t*)(arg6), (size_t)(arg7) };
  md5_result_context_errno_t ret;
  md5_update(&arg8, &arg9, &ret);
  int32_t ptr = (int32_t) &RET_AREA;
  if ((ret).is_err) {
    const md5hash_errno_t *payload10 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) *payload10;
  } else {
    const md5hash_context_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int64_t*)(ptr + 8)) = (int64_t) ((*payload).bytes);
    *((int32_t*)(ptr + 16)) = (int32_t) ((*payload).a);
    *((int32_t*)(ptr + 20)) = (int32_t) ((*payload).b);
    *((int32_t*)(ptr + 24)) = (int32_t) ((*payload).c);
    *((int32_t*)(ptr + 28)) = (int32_t) ((*payload).d);
    *((int32_t*)(ptr + 36)) = (int32_t) ((*payload).buffer).len;
    *((int32_t*)(ptr + 32)) = (int32_t) ((*payload).buffer).ptr;
  }
  return ptr;
}

__attribute__((export_name("md5#hash")))
int32_t __wasm_export_md5_hash(int64_t arg, int32_t arg0, int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5) {
  md5hash_context_t arg6 = (md5hash_context_t) {
    (uint64_t) (arg),
    (uint32_t) (arg0),
    (uint32_t) (arg1),
    (uint32_t) (arg2),
    (uint32_t) (arg3),
    (md5_list_u8_t) { (uint8_t*)(arg4), (size_t)(arg5) },
  };
  md5_result_list_u8_errno_t ret;
  md5_hash(&arg6, &ret);
  int32_t ptr = (int32_t) &RET_AREA;
  if ((ret).is_err) {
    const md5hash_errno_t *payload7 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 4)) = (int32_t) *payload7;
  } else {
    const md5_list_u8_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int32_t*)(ptr + 8)) = (int32_t) (*payload).len;
    *((int32_t*)(ptr + 4)) = (int32_t) (*payload).ptr;
  }
  return ptr;
}

extern void __component_type_object_force_link_md5(void);
void __component_type_object_force_link_md5_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_md5();
}
